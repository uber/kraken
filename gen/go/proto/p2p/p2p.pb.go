// Copyright (c) 2016-2019 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Code generated by protoc-gen-go.
// source: proto/p2p/p2p.proto
// DO NOT EDIT!

/*
Package p2p is a generated protocol buffer package.

It is generated from these files:
	proto/p2p/p2p.proto

It has these top-level messages:
	BitfieldMessage
	PieceRequestMessage
	PiecePayloadMessage
	AnnouncePieceMessage
	CancelPieceMessage
	ErrorMessage
	CompleteMessage
	Message
*/
package p2p

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ErrorMessage_ErrorCode int32

const (
	ErrorMessage_PIECE_REQUEST_FAILED ErrorMessage_ErrorCode = 0
)

var ErrorMessage_ErrorCode_name = map[int32]string{
	0: "PIECE_REQUEST_FAILED",
}
var ErrorMessage_ErrorCode_value = map[string]int32{
	"PIECE_REQUEST_FAILED": 0,
}

func (x ErrorMessage_ErrorCode) String() string {
	return proto.EnumName(ErrorMessage_ErrorCode_name, int32(x))
}
func (ErrorMessage_ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type Message_Type int32

const (
	Message_BITFIELD      Message_Type = 0
	Message_PIECE_REQUEST Message_Type = 1
	Message_PIECE_PAYLOAD Message_Type = 2
	Message_ANNOUCE_PIECE Message_Type = 3
	Message_CANCEL_PIECE  Message_Type = 4
	Message_ERROR         Message_Type = 5
	Message_COMPLETE      Message_Type = 6
)

var Message_Type_name = map[int32]string{
	0: "BITFIELD",
	1: "PIECE_REQUEST",
	2: "PIECE_PAYLOAD",
	3: "ANNOUCE_PIECE",
	4: "CANCEL_PIECE",
	5: "ERROR",
	6: "COMPLETE",
}
var Message_Type_value = map[string]int32{
	"BITFIELD":      0,
	"PIECE_REQUEST": 1,
	"PIECE_PAYLOAD": 2,
	"ANNOUCE_PIECE": 3,
	"CANCEL_PIECE":  4,
	"ERROR":         5,
	"COMPLETE":      6,
}

func (x Message_Type) String() string {
	return proto.EnumName(Message_Type_name, int32(x))
}
func (Message_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

// Binary set of all pieces that peer has downloaded so far. Also serves as a
// handshaking message, which each peer sends once at the beginning of the
// connection to declare what their peer id is and what info hash they want to
// transmit.
type BitfieldMessage struct {
	InfoHash string `protobuf:"bytes,2,opt,name=infoHash" json:"infoHash,omitempty"`
	// TODO: Torrent name is the content hash. Current torrent storage is
	// content addressable. Adding name as a part of handshake makes looking
	// up torrents faster. If storage supports addressing torrent by infohash,
	// this extra field should removed.
	// XXX(codyg): We rely on this name field for announcing too, so tracker can
	// look up origins that have this content.
	// We currently treat infohash as verification of torrents.
	Name          string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	PeerID        string `protobuf:"bytes,4,opt,name=peerID" json:"peerID,omitempty"`
	BitfieldBytes []byte `protobuf:"bytes,5,opt,name=bitfieldBytes,proto3" json:"bitfieldBytes,omitempty"`
	Namespace     string `protobuf:"bytes,6,opt,name=namespace" json:"namespace,omitempty"`
	// remoteBitfieldBytes contains the binary sets of pieces downloaded of
	// all peers that the sender is currently connected to.
	RemoteBitfieldBytes map[string][]byte `protobuf:"bytes,7,rep,name=remoteBitfieldBytes" json:"remoteBitfieldBytes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *BitfieldMessage) Reset()                    { *m = BitfieldMessage{} }
func (m *BitfieldMessage) String() string            { return proto.CompactTextString(m) }
func (*BitfieldMessage) ProtoMessage()               {}
func (*BitfieldMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *BitfieldMessage) GetRemoteBitfieldBytes() map[string][]byte {
	if m != nil {
		return m.RemoteBitfieldBytes
	}
	return nil
}

// Requests a piece of the given index. Note: offset and length are unused fields
// and if set, will be rejected.
type PieceRequestMessage struct {
	Index  int32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
	Offset int32 `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
	Length int32 `protobuf:"varint,4,opt,name=length" json:"length,omitempty"`
}

func (m *PieceRequestMessage) Reset()                    { *m = PieceRequestMessage{} }
func (m *PieceRequestMessage) String() string            { return proto.CompactTextString(m) }
func (*PieceRequestMessage) ProtoMessage()               {}
func (*PieceRequestMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// Provides binary payload response to a peer request. Always immediately followed
// by a binary blob sent over socket, so the receiver should be ready to treat the
// blob as a non-protobuf message.
type PiecePayloadMessage struct {
	Index  int32  `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
	Offset int32  `protobuf:"varint,3,opt,name=offset" json:"offset,omitempty"`
	Length int32  `protobuf:"varint,4,opt,name=length" json:"length,omitempty"`
	Digest string `protobuf:"bytes,5,opt,name=digest" json:"digest,omitempty"`
}

func (m *PiecePayloadMessage) Reset()                    { *m = PiecePayloadMessage{} }
func (m *PiecePayloadMessage) String() string            { return proto.CompactTextString(m) }
func (*PiecePayloadMessage) ProtoMessage()               {}
func (*PiecePayloadMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Announces that a piece is available to other peers.
type AnnouncePieceMessage struct {
	Index int32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
}

func (m *AnnouncePieceMessage) Reset()                    { *m = AnnouncePieceMessage{} }
func (m *AnnouncePieceMessage) String() string            { return proto.CompactTextString(m) }
func (*AnnouncePieceMessage) ProtoMessage()               {}
func (*AnnouncePieceMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// Unused.
type CancelPieceMessage struct {
	Index int32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
}

func (m *CancelPieceMessage) Reset()                    { *m = CancelPieceMessage{} }
func (m *CancelPieceMessage) String() string            { return proto.CompactTextString(m) }
func (*CancelPieceMessage) ProtoMessage()               {}
func (*CancelPieceMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// General purpose error message. Receivers may check the error code to determine
// the origin of the message.
type ErrorMessage struct {
	Error string                 `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	Index int32                  `protobuf:"varint,3,opt,name=index" json:"index,omitempty"`
	Code  ErrorMessage_ErrorCode `protobuf:"varint,4,opt,name=code,enum=p2p.ErrorMessage_ErrorCode" json:"code,omitempty"`
}

func (m *ErrorMessage) Reset()                    { *m = ErrorMessage{} }
func (m *ErrorMessage) String() string            { return proto.CompactTextString(m) }
func (*ErrorMessage) ProtoMessage()               {}
func (*ErrorMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// Notifies other peers that the torrent has completed and all pieces are available.
type CompleteMessage struct {
}

func (m *CompleteMessage) Reset()                    { *m = CompleteMessage{} }
func (m *CompleteMessage) String() string            { return proto.CompactTextString(m) }
func (*CompleteMessage) ProtoMessage()               {}
func (*CompleteMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type Message struct {
	Version       string                `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	Type          Message_Type          `protobuf:"varint,2,opt,name=type,enum=p2p.Message_Type" json:"type,omitempty"`
	Bitfield      *BitfieldMessage      `protobuf:"bytes,3,opt,name=bitfield" json:"bitfield,omitempty"`
	PieceRequest  *PieceRequestMessage  `protobuf:"bytes,4,opt,name=pieceRequest" json:"pieceRequest,omitempty"`
	PiecePayload  *PiecePayloadMessage  `protobuf:"bytes,5,opt,name=piecePayload" json:"piecePayload,omitempty"`
	AnnouncePiece *AnnouncePieceMessage `protobuf:"bytes,6,opt,name=announcePiece" json:"announcePiece,omitempty"`
	CancelPiece   *CancelPieceMessage   `protobuf:"bytes,7,opt,name=cancelPiece" json:"cancelPiece,omitempty"`
	Error         *ErrorMessage         `protobuf:"bytes,8,opt,name=error" json:"error,omitempty"`
	Complete      *CompleteMessage      `protobuf:"bytes,9,opt,name=complete" json:"complete,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Message) GetBitfield() *BitfieldMessage {
	if m != nil {
		return m.Bitfield
	}
	return nil
}

func (m *Message) GetPieceRequest() *PieceRequestMessage {
	if m != nil {
		return m.PieceRequest
	}
	return nil
}

func (m *Message) GetPiecePayload() *PiecePayloadMessage {
	if m != nil {
		return m.PiecePayload
	}
	return nil
}

func (m *Message) GetAnnouncePiece() *AnnouncePieceMessage {
	if m != nil {
		return m.AnnouncePiece
	}
	return nil
}

func (m *Message) GetCancelPiece() *CancelPieceMessage {
	if m != nil {
		return m.CancelPiece
	}
	return nil
}

func (m *Message) GetError() *ErrorMessage {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *Message) GetComplete() *CompleteMessage {
	if m != nil {
		return m.Complete
	}
	return nil
}

func init() {
	proto.RegisterType((*BitfieldMessage)(nil), "p2p.BitfieldMessage")
	proto.RegisterType((*PieceRequestMessage)(nil), "p2p.PieceRequestMessage")
	proto.RegisterType((*PiecePayloadMessage)(nil), "p2p.PiecePayloadMessage")
	proto.RegisterType((*AnnouncePieceMessage)(nil), "p2p.AnnouncePieceMessage")
	proto.RegisterType((*CancelPieceMessage)(nil), "p2p.CancelPieceMessage")
	proto.RegisterType((*ErrorMessage)(nil), "p2p.ErrorMessage")
	proto.RegisterType((*CompleteMessage)(nil), "p2p.CompleteMessage")
	proto.RegisterType((*Message)(nil), "p2p.Message")
	proto.RegisterEnum("p2p.ErrorMessage_ErrorCode", ErrorMessage_ErrorCode_name, ErrorMessage_ErrorCode_value)
	proto.RegisterEnum("p2p.Message_Type", Message_Type_name, Message_Type_value)
}

func init() { proto.RegisterFile("proto/p2p/p2p.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 647 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x54, 0x4f, 0x6f, 0xd3, 0x4e,
	0x10, 0x6d, 0x12, 0x3b, 0x7f, 0x26, 0x69, 0xeb, 0x6c, 0xa3, 0xdf, 0xcf, 0x14, 0x0e, 0x95, 0x45,
	0x45, 0x85, 0xa0, 0xad, 0xcc, 0x05, 0x10, 0x12, 0x4a, 0x1c, 0x57, 0x44, 0x4a, 0x9b, 0xb0, 0xa4,
	0x07, 0xc4, 0xa1, 0x72, 0x9d, 0x49, 0x6b, 0x91, 0x7a, 0x8d, 0xed, 0x56, 0xcd, 0xd7, 0xe0, 0x43,
	0x21, 0xf1, 0xad, 0xd0, 0x4e, 0xec, 0xc4, 0x6e, 0x02, 0xe2, 0xc0, 0x21, 0x92, 0xdf, 0xf3, 0x7b,
	0xb3, 0xb3, 0x33, 0x2f, 0x86, 0x9d, 0x20, 0x14, 0xb1, 0x38, 0x0a, 0xcc, 0x40, 0xfe, 0x0e, 0x09,
	0xb1, 0x52, 0x60, 0x06, 0xc6, 0x8f, 0x22, 0x6c, 0x77, 0xbc, 0x78, 0xe2, 0xe1, 0x74, 0x7c, 0x8a,
	0x51, 0xe4, 0x5c, 0x21, 0xdb, 0x85, 0xaa, 0xe7, 0x4f, 0xc4, 0x07, 0x27, 0xba, 0xd6, 0x8b, 0x7b,
	0x85, 0x83, 0x1a, 0x5f, 0x60, 0xc6, 0x40, 0xf1, 0x9d, 0x1b, 0xd4, 0x4b, 0xc4, 0xd3, 0x33, 0xfb,
	0x0f, 0xca, 0x01, 0x62, 0xd8, 0xeb, 0xea, 0x0a, 0xb1, 0x09, 0x62, 0x4f, 0x61, 0xf3, 0x32, 0x29,
	0xdd, 0x99, 0xc5, 0x18, 0xe9, 0xea, 0x5e, 0xe1, 0xa0, 0xc1, 0xf3, 0x24, 0x7b, 0x02, 0x35, 0x59,
	0x25, 0x0a, 0x1c, 0x17, 0xf5, 0x32, 0x15, 0x58, 0x12, 0xec, 0x02, 0x76, 0x42, 0xbc, 0x11, 0x31,
	0x76, 0x72, 0x95, 0x2a, 0x7b, 0xa5, 0x83, 0xba, 0xf9, 0xf2, 0x50, 0xde, 0xe6, 0x41, 0xfb, 0x87,
	0x7c, 0x55, 0x6f, 0xfb, 0x71, 0x38, 0xe3, 0xeb, 0x2a, 0xed, 0x9e, 0x80, 0xfe, 0x3b, 0x03, 0xd3,
	0xa0, 0xf4, 0x15, 0x67, 0x7a, 0x81, 0x9a, 0x92, 0x8f, 0xac, 0x05, 0xea, 0x9d, 0x33, 0xbd, 0x45,
	0x9a, 0x4b, 0x83, 0xcf, 0xc1, 0xdb, 0xe2, 0xeb, 0x82, 0xf1, 0x05, 0x76, 0x86, 0x1e, 0xba, 0xc8,
	0xf1, 0xdb, 0x2d, 0x46, 0x71, 0x3a, 0xcb, 0x16, 0xa8, 0x9e, 0x3f, 0xc6, 0x7b, 0x32, 0xa8, 0x7c,
	0x0e, 0xe4, 0xc4, 0xc4, 0x64, 0x12, 0x61, 0x4c, 0x73, 0x54, 0x79, 0x82, 0x24, 0x3f, 0x45, 0xff,
	0x2a, 0xbe, 0xa6, 0x49, 0xaa, 0x3c, 0x41, 0x46, 0x94, 0x14, 0x1f, 0x3a, 0xb3, 0xa9, 0x70, 0xc6,
	0xff, 0xb4, 0xb8, 0xe4, 0xc7, 0xde, 0x15, 0x46, 0x31, 0xed, 0xa7, 0xc6, 0x13, 0x64, 0xbc, 0x80,
	0x56, 0xdb, 0xf7, 0xc5, 0xad, 0xef, 0x22, 0x1d, 0xfe, 0xc7, 0x53, 0x8d, 0xe7, 0xc0, 0x2c, 0xc7,
	0x77, 0x71, 0xfa, 0x17, 0xda, 0xef, 0x05, 0x68, 0xd8, 0x61, 0x28, 0xc2, 0x8c, 0x0c, 0x25, 0x4e,
	0xe2, 0x36, 0x07, 0x4b, 0x73, 0x29, 0x7b, 0xbd, 0x23, 0x50, 0x5c, 0x31, 0x46, 0xba, 0xc4, 0x96,
	0xf9, 0x98, 0x22, 0x90, 0x2d, 0x36, 0x07, 0x96, 0x18, 0x23, 0x27, 0xa1, 0xb1, 0x0f, 0xb5, 0x05,
	0xc5, 0x74, 0x68, 0x0d, 0x7b, 0xb6, 0x65, 0x5f, 0x70, 0xfb, 0xe3, 0xb9, 0xfd, 0x69, 0x74, 0x71,
	0xd2, 0xee, 0xf5, 0xed, 0xae, 0xb6, 0x61, 0x34, 0x61, 0xdb, 0x12, 0x37, 0xc1, 0x14, 0xe3, 0xb4,
	0x7b, 0xe3, 0xa7, 0x02, 0x95, 0xb4, 0x45, 0x1d, 0x2a, 0x77, 0x18, 0x46, 0x9e, 0xf0, 0x93, 0x3c,
	0xa4, 0x90, 0xed, 0x83, 0x12, 0xcf, 0x82, 0x79, 0x24, 0xb6, 0xcc, 0x26, 0x35, 0x94, 0xf6, 0x32,
	0x9a, 0x05, 0xc8, 0xe9, 0x35, 0x3b, 0x86, 0x6a, 0x1a, 0x7c, 0xba, 0x50, 0xdd, 0x6c, 0xad, 0x8b,
	0x2f, 0x5f, 0xa8, 0xd8, 0x3b, 0x68, 0x04, 0x99, 0x48, 0xd1, 0x8d, 0xeb, 0xa6, 0x4e, 0xae, 0x35,
	0x59, 0xe3, 0x39, 0xf5, 0xc2, 0x9d, 0x64, 0x86, 0x96, 0x9b, 0x73, 0xe7, 0xc3, 0xc4, 0x73, 0x6a,
	0xf6, 0x1e, 0x36, 0x9d, 0xec, 0xf2, 0xe9, 0x9f, 0x59, 0x37, 0x1f, 0x91, 0x7d, 0x5d, 0x2c, 0x78,
	0x5e, 0xcf, 0xde, 0x40, 0xdd, 0x5d, 0xe6, 0x41, 0xaf, 0x90, 0xfd, 0x7f, 0xb2, 0xaf, 0xe6, 0x84,
	0x67, 0xb5, 0xec, 0x59, 0x9a, 0x86, 0x2a, 0x99, 0x9a, 0x2b, 0x2b, 0x4e, 0x03, 0x72, 0x0c, 0x55,
	0x37, 0x59, 0x99, 0x5e, 0xcb, 0x8c, 0xf4, 0xc1, 0x1e, 0xf9, 0x42, 0x65, 0xdc, 0x83, 0x22, 0x57,
	0xc2, 0x1a, 0x50, 0xed, 0xf4, 0x46, 0x27, 0x3d, 0xbb, 0xdf, 0xd5, 0x36, 0x58, 0x13, 0x36, 0x73,
	0xa1, 0xd0, 0x0a, 0x4b, 0x6a, 0xd8, 0xfe, 0xdc, 0x1f, 0xb4, 0xbb, 0x5a, 0x51, 0x52, 0xed, 0xb3,
	0xb3, 0xc1, 0xb9, 0x24, 0xe5, 0x2b, 0xad, 0xc4, 0x34, 0x68, 0x58, 0xed, 0x33, 0xcb, 0xee, 0x27,
	0x8c, 0xc2, 0x6a, 0xa0, 0xda, 0x9c, 0x0f, 0xb8, 0xa6, 0xca, 0x33, 0xac, 0xc1, 0xe9, 0xb0, 0x6f,
	0x8f, 0x6c, 0xad, 0x7c, 0x59, 0xa6, 0x8f, 0xee, 0xab, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xfd,
	0x11, 0xd8, 0xe6, 0x8b, 0x05, 0x00, 0x00,
}
